/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sequence;

import interfaces.AssignWithFunction;
import interfaces.MapFunction;
import interfaces.MapPredicate;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import lodash.Maps;

/**
 * Chain map methods.
 * @author Justis
 * @param <K> The type of the key.
 * @param <V> The type of the value.
 */
public class MapChain<K, V> {
    
    private final Map<K, V> map;
    
    public MapChain(Map<K, V> map){
        this.map = map;
    }
    
    public Map<K, V> value(){
        return map;
    }
    
    /**
     * Add the list of keys and values to the source map
     * @param sources The sources of additional key/values
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> assign(Map<K, V>... sources){
        return new MapChain<>(
                Maps.assign(map, Arrays.asList(sources))
        );
    }
    
    /**
     * Add the list of keys and values to the source map
     * @param sources The sources of additional key/values
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> assign(List<Map<K, V>> sources){
        return new MapChain<>(Maps.assign(map, sources));
    }
    
    /**
     * Add they keys and values of a list of maps to the source map, after using a customizer.
     * The customizer receives five parameters:
     * - The value at the current key in the map, or null if none.
     * - The value at the current key in the current source.
     * - The key being evaluated.
     * - An unmodifiable copy of the map.
     * - An unmodifiable copy of the current source.
     * @param sources The sources of the keys and values to add.
     * @param customizer The customizer, to calculate the values of each key.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> assignWith(List<Map<K, V>> sources, AssignWithFunction<K, V> customizer){
        return new MapChain<>(Maps.assignWith(map, sources, customizer));
    }
    
    /**
     * Add the keys and values of a map to an initial map, after using a customizer.
     * The customizer receives five parameters:
     * - The value at the current key in the map, or null if none.
     * - The value at the current key in the current source.
     * - The key being evaluated.
     * - An unmodifiable copy of the map.
     * - An unmodifiable copy of the current source.
     * @param source The sources of the keys and values to add.
     * @param customizer The customizer, to calculate the values of each key.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> assignWith(Map<K, V> source, AssignWithFunction<K, V> customizer){
        return new MapChain<>(Maps.assignWith(map, source, customizer));
    }
    
    /**
     * Return the values at the specified keys.
     * @param paths The keys to retrieve.
     * @return The ListChain to continue chaining.
     */
    public ListChain<V> at(K... paths){
        return new ListChain<>(Maps.at(map, Arrays.asList(paths)));
    }
    
    /**
     * Return the values at the specified keys.
     * @param paths The keys to retrieve.
     * @return The ListChain to continue chaining.
     */
    public ListChain<V> at(List<K> paths){
        return new ListChain<>(Maps.at(map, paths));
    }
    
    /**
     * Adds default key/values to the source map if not present.
     * @param defaults The defaults to use.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> defaults(Map<K, V> defaults){
        return new MapChain<>(Maps.defaults(map, defaults));
    }
    
    /**
     * Creates a map where values are keys and vice versa.
     * @return The MapChain to continue chaining.
     */
    public MapChain<V, K> invert(){
        return new MapChain<>(Maps.invert(map));
    }
    
    /**
     * Creates a map where keys become values, and values run through iteratee to become keys.
     * @param <R> The type the values are converted to.
     * @param iteratee The function to convert values into their new keys.
     * @return The MapChain to continue chaining.
     */
    public <R> MapChain<R, K> invertBy(Function<V, R> iteratee){
        return new MapChain<>(Maps.invertBy(map, iteratee));
    }
    
    /**
     * Creates a map where keys are generated by running values through iteratee.
     * @param <R> The type the values are converted to.
     * @param iteratee The function to turn values into keys.
     * @return The MapChain to continue chaining.
     */
    public <R> MapChain<R, V> keyBy(Function<V, R> iteratee){
        return new MapChain<>(lodash.Collections.keyBy(map, iteratee));
    }
    
    /**
     * Return all the keys of a map.
     * @return The ListChain to continue chaining.
     */
    public ListChain<K> keys(){
        return new ListChain<>(Maps.keys(map));
    }
    
    /**
     * Return the values of the source map after running through iteratee.
     * @param <R> The type the keys are converted to.
     * @param iteratee The mapping function.
     * @return The ListChain to continue chaining.
     */
    public <R> ListChain<R> map(Function<V, R> iteratee){
        return new ListChain<>(lodash.Collections.map(map, iteratee));
    }
    
    /**
     * Create a map by running keys through an iteratee for new keys.
     * @param <R> The type the keys are turned into.
     * @param iteratee The function to turn old keys into new keys.
     * @return The MapChain to continue chaining.
     */
    public <R> MapChain<R, V> mapKeys(MapFunction<K, V, R> iteratee){
        return new MapChain<>(Maps.mapKeys(map, iteratee));
    }
    
    /**
     * Create a map by running keys through an iteratee for new keys.
     * @param <R> The type the keys are turned into.
     * @param iteratee The function to turn old keys into new keys.
     * @return The MapChain to continue chaining.
     */
    public <R> MapChain<R, V> mapKeys(Function<K, R> iteratee){
        return new MapChain<>(Maps.mapKeys(map, iteratee));
    }
    
    /**
     * Create a map by running values through an iteratee for new values.
     * @param <R> The type the values are turned into.
     * @param iteratee The function to turn old values into new values.
     * @return The MapChain to continue chaining.
     */
    public <R> MapChain<K, R> mapValues(MapFunction<K, V, R> iteratee){
        return new MapChain<>(Maps.mapValues(map, iteratee));
    }
    
    /**
     * Create a map by running values through an iteratee for new values.
     * @param <R> The type the values are turned into.
     * @param iteratee The function to turn old values into new values.
     * @return The MapChain to continue chaining.
     */
    public <R> MapChain<K, R> mapValues(Function<V, R> iteratee){
        return new MapChain<>(Maps.mapValues(map, iteratee));
    }
    
    //TODO: Matches?
    
    /**
     * Create a copy of the source object, omitting the specified keys.
     * @param keys The keys to omit.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> omit(K... keys){
        return new MapChain(Maps.omit(map, Arrays.asList(keys)));
    }
    
    /**
     * Create a copy of the source object, omitting the specified keys.
     * @param keys The keys to omit.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> omit(List<K> keys){
        return new MapChain<>(Maps.omit(map, keys));
    }
    
    /**
     * Create a copy of the source object, omitting keys that pass the predicate.
     * @param predicate The predicate to determine ommission.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> omitBy(BiPredicate<K, V> predicate){
        return new MapChain<>(Maps.omitBy(map, predicate));
    }
    
    /**
     * Create a copy of the source object, omitting keys that pass the predicate.
     * @param predicate The predicate to determine ommission.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> omitBy(Predicate<K> predicate){
        return new MapChain<>(Maps.omitBy(map, predicate));
    }
    
    /**
     * Create a copy of the source object, with only the specified keys present.
     * @param keys The keys to retain.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> pick(K... keys){
        return new MapChain<>(Maps.pick(map, Arrays.asList(keys)));
    }
    
    /**
     * Create a copy of the source object, with only the specified keys present.
     * @param keys The keys to retain.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> pick(List<K> keys){
        return new MapChain<>(Maps.pick(map, keys));
    }
    
    /**
     * Creates a copy of the source object, with only keys passing a predicate present.
     * @param predicate The predicate to determine retention.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> pickBy(BiPredicate<K, V> predicate){
        return new MapChain<>(Maps.pickBy(map, predicate));
    }
    
    /**
     * Creates a copy of the source object, with only keys passing a predicate present.
     * @param predicate The predicate to determine retention.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> pickBy(Predicate<K> predicate){
        return new MapChain<>(Maps.pickBy(map, predicate));
    }
    
    /**
     * Returns the keys that failed a predicate.
     * @param predicate The predicate to determine rejection.
     * @return The ListChain to continue chaining.
     */
    public ListChain<V> reject(MapPredicate<K, V> predicate){
        return new ListChain<>(lodash.Collections.reject(map, predicate));
    }
    
    /**
     * Returns the keys that failed a predicate.
     * @param predicate The predicate to determine rejection.
     * @return The ListChain to continue chaining.
     */
    public ListChain<V> reject(Predicate<V> predicate){
        return new ListChain<>(lodash.Collections.reject(map, predicate));
    }
    
    /**
     * Retrieve n random values from the source map.
     * @param n The number of values to retrieve.
     * @return The ListChain to continue chaining.
     */
    public ListChain<V> sampleSize(int n){
        return new ListChain<>(lodash.Collections.sampleSize(map, n));
    }
    
    /**
     * Set a key/value pair to the source map.
     * @param key The key.
     * @param value The value.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> set(K key, V value){
        return new MapChain<>(Maps.set(map, key, value));
    }
    
    /**
     * Return the keys, randomly shuffled.
     * @return The MapChain to continue chaining.
     */
    public ListChain<V> shuffle(){
        return new ListChain<>(lodash.Collections.shuffle(map));
    }
    
    /**
     * Remove a key from the map.
     * @param key The key to remove.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> unset(K key){
        Maps.unset(map, key);
        return this;
    }
    
    /**
     * Allows tapping into a chain sequence to do some logic.
     * @param consumer The function that does work on the source map.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> tap(Consumer<Map<K, V>> consumer){
        consumer.accept(map);
        return this;
    }
    
    /**
     * Allows tapping into a chain sequence to convert the source map in some way.
     * This is like tap, except the chain continues with the results of applying
     * the function, rather than modifying the source list directly.
     * @param <L> The type of the key in the new MapChain.
     * @param <W> The type of the value in the new MapChain.
     * @param function The function to convert the source list into a new list.
     * @return The MapChain wrapping the result of applying function with the source map.
     */
    public <L, W> MapChain<L, W> thru(Function<Map<K, V>, Map<L, W>> function){
        return new MapChain<>(function.apply(map));
    }
    
    /**
     * Updates the value at the specified key in the source map.
     * @param key The key to update.
     * @param updater A function that updates the value from the old one.
     * @return The MapChain to continue chaining.
     */
    public MapChain<K, V> update(K key, UnaryOperator<V> updater){
        return new MapChain<>(Maps.update(map, key, updater));
    }
    
    /**
     * Retrieve the values of the source map.
     * @return The ListChain to continue chaining.
     */
    public ListChain<V> values(){
        return new ListChain<>(Maps.values(map));
    }
}
